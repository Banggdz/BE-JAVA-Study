
- Reference Documentation:
https://docs.spring.io/spring-data/data-jpa/docs/1.4.x/reference/htmlsingle/#repositories.query-methods
- ORM:
ORM lÃ  1 ká»¹ thuáº­t láº­p trÃ¬nh giÃºp Ã¡nh xáº¡ cÃ¡c record dá»¯ liá»‡u trong há»‡ quáº£n trá»‹ cÆ¡ sá»Ÿ dá»¯ liá»‡u sang dáº¡ng Ä‘á»‘i tÆ°á»£ng Ä‘ang Ä‘á»‹nh nghÄ©a trong cÃ¡c class
https://viblo.asia/p/object-relational-mapping-djeZ1PQ3KWz
https://thorben-janssen.com/best-practices-many-one-one-many-associations-mappings/
https://www.tutorialspoint.com/jpa/jpa_architecture.htm
https://www.baeldung.com/jpql-hql-criteria-query
https://stackoverflow.com/questions/50322550/hibernate-dialect-for-mysql-8

LÃ m viá»‡c vá»›i JPA cÃ³ 2 cÃ¡ch chÃ­nh:
- JPQL (Java Persistence Query Language) : NgÃ´n ngá»¯ truy váº¥n hÆ°á»›ng Ä‘á»‘i tÆ°á»£ng (Object-Oriented Query Language).
	+ Sá»­ dá»¥ng hoÃ n toÃ n vá»›i cÃ¡c Ä‘á»‘i tÆ°á»£ng Entity trong Java.
	+ Truy váº¥n mang tÃ­nh hÆ°á»›ng Ä‘á»‘i tÆ°á»£ng, khÃ´ng phá»¥ thuá»™c vÃ o cáº¥u trÃºc báº£ng csdl, Khi cháº¡y, Hibernate/EclipseLink sáº½ dá»‹ch JPQL thÃ nh SQL gá»‘c phÃ¹ há»£p vá»›i DB báº¡n dÃ¹ng..
	+ VD: String sql = "FROM BuildingEntity b";
	      Query query = entityManager.createQuery(sql,BuildingEntity.class);
		  return query.getResultList();
ğŸ‘‰ á» Ä‘Ã¢y:
	+ BuildingEntity lÃ  tÃªn Entity class.
	+ b.name lÃ  thuá»™c tÃ­nh trong class BuildingEntity.
	+ KhÃ´ng quan tÃ¢m báº£ng tháº­t trong DB tÃªn gÃ¬ (building, tbl_building, ...).

- Native Query
	+ Viáº¿t truy váº¥n SQL thuáº§n, gáº§n giá»‘ng nhÆ° cÃ¡ch lÃ m viá»‡c trá»±c tiáº¿p vá»›i cÆ¡ sá»Ÿ dá»¯ liá»‡u.
	+ Dá»… dÃ ng táº­n dá»¥ng cÃ¡c tÃ­nh nÄƒng Ä‘áº·c thÃ¹ cá»§a há»‡ quáº£n trá»‹ cÆ¡ sá»Ÿ dá»¯ liá»‡u.
	+ VD: String sql = "FROM BuildingEntity b WHERE b.name like '%building%";
		  Query query = entityManager.createNativeQuery(sql,BuildingEntity.class);
		  return query.getResultList();
ğŸ‘‰ á» Ä‘Ã¢y:
+ building lÃ  tÃªn báº£ng trong DB.
+ name lÃ  tÃªn cá»™t tháº­t trong báº£ng.
+ CÃ¢u query phá»¥ thuá»™c vÃ o loáº¡i DB (MySQL, Oracle, PostgreSQLâ€¦).
---- Persistent Context
https://www.baeldung.com/jpa-hibernate-persistence-context
- Má»™t instance cá»§a EntityManager Ä‘Æ°á»£c gáº¯n vá»›i má»™t persistence context. Persistence context lÃ  táº­p há»£p cÃ¡c entity, trong Ä‘Ã³ má»—i Ä‘á»‹nh danh entity chá»‰ tá»“n táº¡i duy nháº¥t má»™t instance. 
BÃªn trong persistence context, cÃ¡c entity vÃ  vÃ²ng Ä‘á»i cá»§a chÃºng Ä‘Æ°á»£c quáº£n lÃ½. 
EntityManager API Ä‘Æ°á»£c dÃ¹ng Ä‘á»ƒ táº¡o, xÃ³a entity, tÃ¬m kiáº¿m theo khÃ³a chÃ­nh, vÃ  thá»±c hiá»‡n query: persist(), merge(), remove(), find(), createQuery()
ğŸ‘‰Persistence context lÃ  bá»™ nhá»› Ä‘á»‡m cáº¥p má»™t (first-level cache), nÆ¡i táº¥t cáº£ cÃ¡c entity Ä‘Æ°á»£c láº¥y ra tá»« cÆ¡ sá»Ÿ dá»¯ liá»‡u hoáº·c Ä‘Æ°á»£c lÆ°u vÃ o cÆ¡ sá»Ÿ dá»¯ liá»‡u. NÃ³ náº±m á»Ÿ giá»¯a á»©ng dá»¥ng cá»§a chÃºng ta vÃ  táº§ng lÆ°u trá»¯ dá»¯ liá»‡u
ğŸ‘‰Persistence context theo dÃµi má»i thay Ä‘á»•i Ä‘Æ°á»£c thá»±c hiá»‡n trÃªn managed entity. NÃ³ theo dÃµi thay Ä‘á»•i cá»§a entity. Khi transaction káº¿t thÃºc, thay Ä‘á»•i nÃ y sáº½ Ä‘Æ°á»£c flush (ghi ra) vÃ o database
ğŸ‘‰Persistence Context chÃ­nh lÃ  nÆ¡i Hibernate/JPA giá»¯ cÃ¡c entity Ä‘ang Ä‘Æ°á»£c quáº£n lÃ½, Ä‘áº£m báº£o chÃºng Ä‘á»“ng bá»™ vá»›i database.
ğŸ‘‰EntityManager lÃ  interface cho phÃ©p chÃºng ta tÆ°Æ¡ng tÃ¡c vá»›i persistence context. Báº¥t cá»© khi nÃ o chÃºng ta sá»­ dá»¥ng EntityManager, thá»±c cháº¥t chÃºng ta Ä‘ang lÃ m viá»‡c vá»›i persistence context.

ğŸŸ¢ Flush lÃ  gÃ¬?
	Flush = quÃ¡ trÃ¬nh Ä‘á»“ng bá»™ (synchronize) tráº¡ng thÃ¡i cá»§a cÃ¡c entity trong Persistence Context (bá»™ nhá»› táº¡m/first-level cache) xuá»‘ng cÆ¡ sá»Ÿ dá»¯ liá»‡u (DB).
	ğŸ‘‰Ä‘áº©y cÃ¡c thay Ä‘á»•i tá»« Persistence Context â†’ DB.

ğŸŸ¢ persist lÃ  gÃ¬?
	persist() lÃ  phÆ°Æ¡ng thá»©c cá»§a EntityManager dÃ¹ng Ä‘á»ƒ lÆ°u má»™t entity má»›i vÃ o persistence context (nghÄ©a lÃ  Ä‘Æ°a entity vÃ o tráº¡ng thÃ¡i Managed).
	Khi gá»i persist(), entity chÆ°a cháº¯c Ä‘Ã£ Ä‘Æ°á»£c ghi ngay xuá»‘ng database, mÃ  nÃ³ sáº½ Ä‘Æ°á»£c quáº£n lÃ½ trong Persistence Context trÆ°á»›c.
- CÃ³ 2 loáº¡i:
â¤ï¸ Transaction-scoped persistence context:
	Gáº¯n liá»n vá»›i má»™t transaction (persistence context Ä‘Æ°á»£c táº¡o khi transaction báº¯t Ä‘áº§u vÃ  bá»‹ há»§y khi transaction káº¿t thÃºc (commit/rollback))
	Khi transaction káº¿t thÃºc, cÃ¡c entity trong persistence context Ä‘Æ°á»£c flush xuá»‘ng DB.
	Náº¿u cÃ³ persistence context Ä‘ang tá»“n táº¡i, nÃ³ sáº½ Ä‘Æ°á»£c dÃ¹ng láº¡i; náº¿u khÃ´ng, EntityManager sáº½ táº¡o má»›i.
	Máº·c Ä‘á»‹nh loáº¡i persistence context lÃ  PersistenceContextType.TRANSACTION. Viáº¿t gá»n: @PersistenceContext:
â¤ï¸ Extended-scoped persistence context:
	Gáº¯n vá»›i vÃ²ng Ä‘á»i EntityManager/bean -> CÃ³ thá»ƒ tá»“n táº¡i qua nhiá»u transaction.
	CÃ³ thá»ƒ persist entity mÃ  khÃ´ng cáº§n transaction, nhÆ°ng khÃ´ng thá»ƒ flush náº¿u khÃ´ng cÃ³ transaction.
âš ï¸ Trong Stateless Session Bean, extended persistence context cá»§a má»—i component lÃ  Ä‘á»™c láº­p.
VÃ­ dá»¥: persist á»Ÿ Component A khÃ´ng thá»ƒ tháº¥y trong Component B (ngay cáº£ khi cÃ¹ng transaction).
VD:
@Component
public class TransctionPersistenceContextUserService {

    @PersistenceContext
    private EntityManager entityManager;
    
    @Transactional
    public User insertWithTransaction(User user) {
        entityManager.persist(user);
        return user;
    }
    
    public User find(long id) {
        return entityManager.find(User.class, id);
    }
}
--- Many-To-One and One-To-Many Association Mappings
VD:
â™¦ Entity PurchaseOrder:
@Entity
@Table(name = "purchase_order")
public class PurchaseOrder {
    @Id
    private Long id;
}
â™¦ Entity Item
@Entity
@Table(name = "item")
public class Item {
    @Id
    private Long id;

    @ManyToOne
    @JoinColumn(name = "fk_order") // cá»™t nÃ y náº±m trong báº£ng item trong db
    private PurchaseOrder order;
}
ğŸ«µ - @Entity â†’ Hibernate/JPA biáº¿t Ä‘Ã¢y lÃ  báº£ng trong cÆ¡ sá»Ÿ dá»¯ liá»‡u.
   - @Table(name = "purchase_order") â†’ chá»‰ Ä‘á»‹nh tÃªn báº£ng trong DB lÃ  purchase_order (náº¿u khÃ´ng khai bÃ¡o, Hibernate sáº½ dÃ¹ng tÃªn class).
   - @Id private Long id; â†’ cá»™t primary key cá»§a báº£ng purchase_order.
   - private PurchaseOrder order: field kiá»ƒu entity â†’ cÃ³ thá»ƒ truy xuáº¥t Item.order.getId() hoáº·c Item.order Ä‘á»ƒ láº¥y toÃ n bá»™ thÃ´ng tin PurchaseOrder. Hibernate tá»± Ä‘á»™ng quáº£n lÃ½ giÃ¡ trá»‹ cá»™t fk_order khi persist/update entity Item.
   - item.getOrder().getId()
	+ item.getOrder() â†’ tráº£ vá» entity PurchaseOrder liÃªn káº¿t vá»›i Item.
    + .getId() â†’ truy cáº­p field id cá»§a entity PurchaseOrder.
    + Hibernate biáº¿t order trá» tá»›i báº£n ghi nÃ o nhá» cá»™t fk_order trong báº£ng item. 
ğŸŸ¢ FetchType.LAZY and FetchType.EAGER
- FetchType.EAGER:
	Theo chuáº©n JPA, vá»›i cÃ¡c quan há»‡ kiá»ƒu to-one (vÃ­ dá»¥ @ManyToOne, @OneToOne) thÃ¬ máº·c Ä‘á»‹nh sáº½ lÃ  FetchType.EAGER.
	NghÄ©a lÃ : khi báº¡n load 1 entity, Hibernate sáº½ tá»± Ä‘á»™ng load luÃ´n quan há»‡ liÃªn káº¿t (vÃ­ dá»¥ Item thÃ¬ load thÃªm PurchaseOrder Ä‘i kÃ¨m).
	Náº¿u chá»‰ load 1 báº£n ghi, thÃ¬ cÅ©ng chá»‰ cáº§n thÃªm 1 query phá»¥ ná»¯a â†’ khÃ´ng tá»‘n kÃ©m láº¯m.
	NhÆ°ng náº¿u báº¡n láº¥y danh sÃ¡ch nhiá»u Item, thÃ¬ váº¥n Ä‘á» náº£y sinh: Hibernate pháº£i cháº¡y thÃªm 1 query phá»¥ cho má»—i báº£n ghi Item Ä‘á»ƒ láº¥y PurchaseOrder.
	N+1 SELECT problem (váº¥n Ä‘á» N+1 truy váº¥n)

VÃ­ dá»¥:
List<Item> items = em.createQuery("SELECT i FROM Item i", Item.class).getResultList();

Hibernate sáº½ cháº¡y 1 query Ä‘á»ƒ láº¥y táº¥t cáº£ Item.
Sau Ä‘Ã³, vá»›i má»—i Item, nÃ³ tá»± Ä‘á»™ng cháº¡y thÃªm 1 query riÃªng Ä‘á»ƒ láº¥y PurchaseOrder. (Hibernate tá»± Ä‘á»™ng load luÃ´n quan há»‡ liÃªn káº¿t)
Náº¿u cÃ³ 100 item â†’ 1 query ban Ä‘áº§u + 100 query phá»¥ = 101 query â†’ ráº¥t cháº­m.

ğŸ”¶Log SQL minh há»a:
-- Query Ä‘áº§u tiÃªn load táº¥t cáº£ Item
	select item0_.id, item0_.name, item0_.fk_order ...
-- Sau Ä‘Ã³, vá»›i tá»«ng Item, load PurchaseOrder
	from Item item0_
	select purchaseor0_.id ...
	from PurchaseOrder purchaseor0_
	where purchaseor0_.id=?
	â†’ Query Ä‘áº§u tiÃªn láº¥y Item, sau Ä‘Ã³ má»—i láº§n láº¡i query tiáº¿p PurchaseOrder theo id.

- FetchType.LAZY: Ä‘á»ƒ giáº£i quyáº¿t n+1 select, for @ManyToOne 
	+ Hibernate khÃ´ng load dá»¯ liá»‡u quan há»‡ ngay láº­p tá»©c, chá»‰ táº¡o má»™t proxy (Ä‘á»‘i tÆ°á»£ng giáº£).
	+ Khi báº¡n thá»±c sá»± truy cáº­p Ä‘áº¿n dá»¯ liá»‡u quan há»‡, Hibernate má»›i cháº¡y SQL Ä‘á»ƒ láº¥y tá»« DB.
	@Entity
	public class Item { 
	    @ManyToOne(fetch = FetchType.LAZY)
	    @JoinColumn(name = "fk_order")
	    private PurchaseOrder order;
	}
	Khi Ä‘á»ƒ LAZY, Hibernate khÃ´ng tá»± Ä‘á»™ng load PurchaseOrder. NÃ³ chá»‰ load khi báº¡n thá»±c sá»± gá»i item.getOrder().
- JOIN FETCH:
@ManyToOne máº·c Ä‘á»‹nh lÃ  EAGER â†’ dá»… gÃ¢y N+1 query.
Báº¡n Ä‘á»•i sang LAZY Ä‘á»ƒ trÃ¡nh N+1 â†’ nhÆ°ng náº¿u báº¡n cáº§n load luÃ´n quan há»‡ thÃ¬ sao?
	
List<Item> items = em.createQuery("SELECT i FROM Item i JOIN FETCH i.order", Item.class).getResultList();

ğŸ«µ i = entity Item
   JOIN FETCH i.order = báº£o Hibernate: â€œjoin luÃ´n báº£ng purchase_order vÃ  tráº£ vá» dá»¯ liá»‡u Ä‘áº§y Ä‘á»§ Ä‘á»ƒ khá»Ÿi táº¡o field order cá»§a Itemâ€.
Hibernate sáº½ dá»‹ch thÃ nh SQL kiá»ƒu:
select i.id, i.name, i.fk_order,
       po.id, po.version
from item i
join purchase_order po on i.fk_order = po.id;
. Káº¿t quáº£

Tráº£ vá» List<Item> (giá»‘ng nhÆ° bÃ¬nh thÆ°á»ng).

NhÆ°ng khÃ¡c biá»‡t lÃ : má»—i Item trong list Ä‘Ã£ cÃ³ order Ä‘Æ°á»£c load sáºµn.

Hibernate khÃ´ng pháº£i cháº¡y thÃªm query phá»¥ khi báº¡n gá»i item.getOrder().
