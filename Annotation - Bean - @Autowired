Nhiệm vụ chính của Spring là tạo ra một cái Container chứa các Dependency cho chúng ta.
SpringApplication.run(App.class, args) là câu lệnh để tạo ra container. 
Sau đó nó tìm toàn bộ các dependency trong project của bạn và đưa vào đó.
Spring đặt tên cho container là ApplicationContext và đặt tên cho các Dependency là bean (muốn dependency là bean phải dùng annotation đánh dấu)
📌Dependency là một class cần sử dụng chức năng/tài nguyên của một class khác để hoạt động.
Ví dụ:
public class OrderService {
    private PaymentService paymentService;
}
👉 Ở đây, OrderService phụ thuộc (depend) vào PaymentService. 
----- @SpringBootApplication: 
Đánh dấu class là application được xây dựng bởi Spring Boot và nó sẽ được khởi tạo từ hàm main của class

----- @Component
📌@Component là một Annotation (chú thích) đánh dấu trên các Class để giúp Spring biết nó là một Bean.
❗Ko dùng cho methods, fields
public interface Outfit {
    public void wear();
}
implement nó là Class Bikini
Đánh dấu class bằng @Component
Class này sẽ được Spring Boot hiểu là một Bean (hoặc dependency) và sẽ được Spring Boot quản lý

@Component
public class Bikini implements Outfit {
    @Override
    public void wear() {
        System.out.println("Mặc bikini");
    }
}
@SpringBootApplication
public class App {
    public static void main(String[] args) {
        // ApplicationContext chính là container, chứa toàn bộ các Bean
        ApplicationContext context = SpringApplication.run(App.class, args);

        // Khi chạy xong, lúc này context sẽ chứa các Bean có đánh dấu @Component.
        // Lấy Bean ra bằng cách
        Outfit outfit = context.getBean(Outfit.class);

        // In ra để xem thử nó là gì
        System.out.println("Instance: " + outfit);
        // xài hàm wear()
        outfit.wear();
    }
}
Output:
[1] Instance: me.loda.spring.helloworld.Bikini@1e1f6d9d
[2] Mặc bikini
Bạn sẽ thấy Outfit lúc này chính là Bikini. Class đã được đánh dấu là @Component.

Spring Boot khi chạy sẽ dò tìm toàn bộ các Class cùng cấp hoặc ở trong các package thấp hơn so với class App mà bạn cung cấp cho Spring 
Khi gặp một class được đánh dấu @Component thì nó sẽ ❗tạo ra một instance (new Bikini) và đưa vào ApplicationContext để quản lý.
🚨Chuyên biệt hóa (specialization) của @Component:
✏️ @Service: Dùng cho tầng Service (Business logic layer), đánh dấu class này chuyên xử lý nghiệp vụ
✏️ @Repository: Dùng cho tầng DAO (Data Access Object / Repository layer).Thao tác trực tiếp với database
    Bắt Exception liên quan đến persistence (CSDL) và chuyển thành Spring DataAccessException.
✏️ @Controller: dùng cho tầng Controller (Spring MVC).
✏️ @RestController: dùng cho REST API (trả JSON/XML).

----- @Autowired
📌@Autowired đánh dấu cho Spring biết rằng sẽ tự động inject bean tương ứng vào vị trí được đánh dấu.

Bây giờ mình tạo ra một Class Girl và có một thuộc tính là Outfit, 
- Đánh dấu Girl là một @Component
👉 Tức Spring Boot cần tạo ra một instance của Girl để quản lý.
- Đánh dấu thuộc tính Outfit của Girl bởi Annotation @Autowired.
👉 Nói với Spring Boot hãy tự ❗inject (tiêm) một instance của Outfit vào thuộc tính này khi khởi tạo Girl.
@Component
public class Girl {
    @Autowired
    Outfit outfit;
    public Girl(Outfit outfit) {
        this.outfit = outfit;
    }
    // GET 
    // SET
}
@SpringBootApplication
public class App {
    public static void main(String[] args) {
        // ApplicationContext chính là container, chứa toàn bộ các Bean
        ApplicationContext context = SpringApplication.run(App.class, args);
        // Khi chạy xong, lúc này context sẽ chứa các Bean có đánh dấu @Component.

        // Lấy Bean ra bằng cách
        Outfit outfit = context.getBean(Outfit.class);

        // In ra để xem thử nó là gì
        System.out.println("Output Instance: " + outfit);
        // xài hàm wear()
        outfit.wear();
        Girl girl = context.getBean(Girl.class);

        System.out.println("Girl Instance: " + girl);
        System.out.println("Girl Outfit: " + girl.outfit);
        girl.outfit.wear();
    }
}
Output:
[1] Output Instance: me.loda.spring.helloworld.Bikini@2e16f13a
[2] Mặc bikini
[3] Girl Instance: me.loda.spring.helloworld.Girl@353cb1cb
[4] Girl Outfit: me.loda.spring.helloworld.Bikini@2e16f13a
[5] Mặc bikini

Spring Boot đã tự tạo ra một Girl và trong quá trình tạo ra đó, nó truyền Outfit vào làm thuộc tính.
Singleton
Các Bean được quản lý bên trong ApplicationContext đều là singleton. Bạn chắc đã để ý điều này từ các Output ở phía trên.

[1] Output Instance: me.loda.spring.helloworld.Bikini@2e16f13a
[4] Girl Outfit: me.loda.spring.helloworld.Bikini@2e16f13a

Outfit ở 2 đối tượng trên là một.
Tất cả những Bean được quản lý trong ApplicationContext đều chỉ được tạo ra một lần duy nhất và khi có Class yêu cầu @Autowired thì nó sẽ lấy đối tượng có sẵn trong ApplicationContext để inject vào.
Trong trường hợp bạn muốn mỗi lần sử dụng là một instance hoàn toàn mới. Thì hãy đánh dấu @Component đó bằng @Scope("prototype")

@Component
@Scope("prototype")
public class Bikini implements Outfit {
    @Override
    public void wear() {
        System.out.println("Mặc bikini");
    }
📌Tóm lại
🔴@Component → tạo ra Bean (instance) và đưa vào IoC Container (ApplicationContext).
🔴@Autowired → lấy Bean đã có sẵn trong Container và gắn vào chỗ bạn cần.

📌 @Autowired có thể đặt ở 3 nơi chính:

🔹Trên constructor → gọi là constructor injection.
🔹Trên field → gọi là field injection.
🔹Trên setter method (như ví dụ bạn đưa) → gọi là setter injection.
